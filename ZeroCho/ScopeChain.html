<script>
    const x = 1;
    // const x = 3;
    // 똑같은 변수 2개 사용시 에러가 발생
    // 하지만 다른 block 에 똑같은 변수명을 사용하는 것은 가능함
    // 같은 변수지만 스코프가 다를 시 같은 변수명 선언이 가능
    // 같은 스코프에 있는 변수를 먼저 실행
    // 같은 스코프에서 먼저 변수를 찾고 없을 시 그 다음 Anonymous 에서 변수를 찾는 순서로 진행


    // ScopeChain - 함수에서 어떤 값에 접근이 가능한지 또한 
    // 어떤 값에 접근이 불가능한가
    //  즉 ScopeChain 은 어떤 변수에 접근을 할수 있는가 기준임 
    // Scope 는 Block 이 기준이 됨 {}
    const test = {
        funTest() {
            let v = 10;
            console.log('funcTest 실행');
            console.log('v 출력 : ' + v);
        }
    }
    function a() {
        const x = 3;
        // Anonymous 변수 x 가아니라
        // 같은 Scope 에 있는 변수 x 를 실행
        console.log('Function a x : ' + x);
        console.log('Function a');
    }
    function c() {
        let cVar = 50;
        console.log('function c')
        {   
            // cVar 접근이 가능함 Block 기준 안에 존재하기 때문에 접근이 가능
            console.log('cVar : ' + cVar);
            let z = 10;
        }
        // 변수 z 에 접근이 안됨 
        // scope 접근 불가 block 이 기준이라 block 밖에 존재하여 접근이 불가
        console.log('a : ' + z);
    }
    c();
    test.funTest();
    // ScopeChain 은 선언을 중점적으로 보아야 함
    // 호출하는 것은 호출 스택으로 표현이 가능
    // 에디터 접어서 분석하는 방법도 용이 최상위에 있는 애들은 
    // 앞에다 Anonymous 라고 기입

    // 파일 전체를 Anonymous 라고 생각을 하면 됨
    
    // Lexical Scope --> 한 번 코딩을 해놓으면 Scope는 바뀔일이 없음
    // 부모함수만 정확히 파악하여 Anonymous 까지 파악을 하여야 함
    
    // ScopeChain 을 구분 잘하는 방법은 들여쓰기를 잘하는것도 중요 함
    function c() {
        const y = 'y';
        console.log('c')
        function b() {
            const z = 'z';
            console.log('function b');
            // b 함수 안에서 a 함수 접근은 가능 
            // Anonymous 최 상단 부분은 접근이 가능하여 함수 접근이 가능
            a();
        }
    }

    function a() {
        const x = 'x';
        console.log('a');
        // a 함수에서 b 접근은 불가능
        // 스코프가 헷갈릴 시 함수 선언만 생각을 하여야 함
        // 함수 내에서 찾고 없을 씨 에디터 부분을 접으면서 Anonymous 최상단 까지 올라간 다음
        // Anonymous 최상단에도 없을 시 접근이 불가능한 것임
        // 사슬처럼 연결되어 있어 ScopeChain 이라고 불림
        b();
    }





</script>